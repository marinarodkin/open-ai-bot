Недавно в интернете я нашёл один очень интересный совет. Суть его заключается в том, как постоянно иметь большой багаж историй, которые можно рассказывать в любой беседе — как в личной, так и в бизнес-коммуникации. Дело в том, что то, что происходило даже неделю назад, а я уж молчу про то, что происходило месяц, полгода или год назад, просто забывается. 

Однако есть простой метод, который позволяет иметь большое количество историй, которые можно в деталях рассказывать. Суть заключается в том, что в конце дня нужно сесть и записать в деталях, эмоционально, какую-либо историю, которая с вами случилась. Это может быть коммуникация с продавцом, встреча с друзьями или, может быть, поездка на шашлык. В общем, что угодно. Вы записываете это, у вас есть дата, когда произошла эта история, и всё. Так как вы её записали, она отложилась в подкорке, и вы будете иметь возможность рассказывать, что с вами происходило.

Я подумал о том, что это даёт определённую дисциплину: нужно каждый вечер записывать истории и описывать их эмоционально. Я же программист, и мне стало интересно, как это дело автоматизировать. Поэтому я решил показать в этом видео небольшой скрипт и идею, как, применяя навыки программирования, можно реализовать такую задачу.

Смотрите, по алгоритму это будет выглядеть следующим образом. Описывать всю историю не хочется, и поэтому я придумал, что мы будем записывать тезисы, которые происходили с нами на протяжении дня. Например, проснулся, выпил кофе, погулял с домашним питомцем, сходил на свидание с друзьями — просто записываем тезисы в Telegram-бота. Дальше всё это идёт на сервер, где чат берёт и на основе этих тезисов с правильным запросом обрабатывает информацию и составляет полноценную историю. После этого, чтобы она сохранялась в базе данных, мы записываем её в Notion. 

Таким образом, у нас по сути есть просто Telegram-бот, в который мы записываем тезисы, и на выходе мы получаем полную страничку, где уже будут описаны все наши истории с датами, эмоциями, правильной последовательностью и так далее. Как это реализовать, я покажу в этом видео. Стек тут будет на JavaScript, ChatGPT и Notion. Все дополнительные материалы на протяжении ролика вы также сможете найти, чтобы каждый из сервисов вам был знаком.

Приятного просмотра! Начнём с разработки. Кстати, потом будет деплой, и я покажу, как обновлять код на удалённом сервере. Это тоже полезная информация с точки зрения деплоя приложений. Короче, контент интересный. В описании также есть мой Telegram-канал, там больше дополнительного контента, тоже подпишитесь.

Итак, для того чтобы реализовать подобную систему, я начинаю с VS Code. Всё это приложение я буду писать на Node.js. В первую очередь нам необходимо инициализировать проект. Я открыл пустой проект, папочка называется notion-gpt-telegram. Создаём терминал, пока не буду обновлять консоль. Итак, инициализируем npm с помощью команды `npm init -y`, чтобы получить package.json. 

Далее сразу же необходимо установить зависимость для разработки — Nodemon, который позволит в автоматическом режиме перезагружать наш сервер. Для этого вводим команду `npm install --save-dev nodemon`. Затем установим некоторые зависимости для работы нашего приложения. Нам потребуется конфиг для того, чтобы выносить различные переменные, OpenAI для работы с GPT, Telegram для работы с Telegram-ботом и также нам потребуется Notion-клиент. Все это устанавливаем, и отлично, теперь в package.json у нас есть необходимые зависимости.

Также добавим здесь Type модуль, чтобы работали импорты и экспорты. Давайте поправим скрипты. У нас будет основной скрипт `start`, который запускает наше приложение. Мы обращаемся к Node и будем говорить, что в папочке `src` нам необходимо запустить `main.js`. Также будет скрипт для разработки, будем делать то же самое, только здесь будем обращаться к Nodemon. Базовая подготовка у нас завершена, и теперь мы можем уже начинать разрабатывать.

Консоль я пока оставлю. Смотрите, так как я указываю основной файл для запуска приложения — это `main.js` в папочке `src`, соответственно, я её вначале создаю. Здесь нам необходимо в первую очередь подключить что-то из Telegram, а это что-то называется `Telegraf`. Видите, автокомплит подсказывает. Это класс, который позволит нам инициализировать бота на JavaScript. Также нам потребуется конфиг из папки `config`, и для того чтобы всё это работало, конфиг обращается к папке `config` в корне и по умолчанию смотрит на файл `default.json`. Здесь в формате JSON мы будем описывать различные ключи, которые потребуются нам для разработки. 

Давайте создадим бота через конструктор `new Telegraf`, куда мы передадим следующие параметры. В первую очередь нам здесь потребуется токен для работы. Telegram работает, и сейчас мы его получим. Давайте напишем конфиг, например, `get Telegram token`. Этот ключ должен содержаться в `default.json`. Пока пусть это будет пустая строка. Также вторым параметром здесь укажем такое свойство, как `handlerTimeout`, и сюда я передам `Infinity`. 

Почему здесь `Infinity`? Потому что мы зависим от API Notion и будем зависеть от API OpenAI, и они по-разному отвечают по времени. Нам нужно, чтобы всё это работало, поэтому такой вот хак позволяет, чтобы бот работал и не сбрасывался. Дальше, что мы делаем с этим ботом? Где-то в конце скрипта мы просто его запускаем с помощью команды `launch`, и также можем обработать команду, например, `start`. Это базовая команда, с которой начинаются любые Telegram-боты. 

Здесь вторым параметром мы принимаем некоторый контекст, и с помощью контекста, например, `reply`, мы можем ответить пользователю, написав, например, "Добро пожаловать в бота! Отправьте текстовые сообщения с тезисами про историю". Вы можете под себя это подделать, в целом, я думаю, что будет понятно. 

Итак, мы будем присылать какие-то тезисы, ключевые слова, и на основе этого бот уже будет создавать собственную историю, которая будет заноситься в Notion. Дальше, команду `start` мы обработали, и теперь пользователь будет примерно понимать, что ему нужно делать. После этого мы будем слушать какое-то сообщение в текстовом формате, на что будет реагировать. Для того чтобы обрабатывать текст, нам также необходимо импортировать фильтр из Telegraf, который называется `message`. 

Дальше мы передаём сюда этот фильтр и говорим, что здесь мы фильтруем только текстовые сообщения. Если мы отправим голосовое сообщение, картинку или файл, он не будет реагировать. Здесь также принимаем некоторый контекст. Давайте пока временно будем здесь отвечать "тест". Это, естественно, поправим на рабочую логику. 

Теперь, для того чтобы всё это работало, нам необходимо получить токен от Telegram. Для этого в Telegram находим бота под названием BotFather. У него есть команда `newbot`, здесь мы должны как-то его назвать. Допустим, я его назову "История Maker". Теперь нам необходимо задать ему username, который должен заканчиваться либо на "bot", либо на "Bot" с большой буквы, либо через нижнее подчеркивание. Давайте напишем "StoryMakerGPT". 

Далее копируем этот токен, вставляем его в конфиг, и в принципе здесь мы переходим сразу же к нашему боту. Понятное дело, что если мы сейчас ничего не сделаем, то ничего не произойдёт. Однако если мы всё это запустим и нажмём "старт", видите, он уже отправляет нам первую команду, то есть то, что мы написали в скрипте. Соответственно, первый шаг у нас пройден, и теперь мы можем продолжать разработку.

Следующее, что мы сделаем, — это разработать логику для ChatGPT. Я сейчас всё подробно поясню. Смотрите, включая VPN, я пользуюсь браузером и перехожу на OpenAI для разработчиков. Если у вас нет аккаунта, его нужно завести. Если у вас есть аккаунт, необходимо сделать логин. Я часто делаю это, чтобы не палить свою почту и пароль. 

Итак, после логина мы попадаем на платформу OpenAI. Здесь нам потребуется перейти в "View API Keys", чтобы посмотреть на ключи. У меня есть основной ключ, я создам новый ключ и назову его "gpt_key". Эти ключи я всё равно удалю после того, как запишу ролик, поэтому копировать мои точно смысла не будет. Тем не менее, я копирую его и заношу дальше в конфиг. Теперь я могу с этим работать. 

Давайте в папке `src` я создам новый файл, допустим, `chatgpt.js`. Здесь я буду описывать логику, которую хочу проделать именно с ChatGPT. В чём заключается идея? Чтобы написать полноценную историю на основе тезисов, мы эти тезисы скармливаем ChatGPT, который умеет работать с лексикой и так далее. Дальше он уже пишет полноценный текст, и после этого мы будем заносить этот текст в Notion, тем самым экономя время. 

Давайте импортируем необходимые библиотеки для работы с ChatGPT и также потребуется OpenAI API. По идее, должны быть эти сущности. Мы сейчас будем их тестировать. Также нам здесь потребуется конфиг. 

Таким образом, мы подходим к завершению первой части разработки.В следующем видео я покажу, как интегрировать всё это в одно целое и как работать с базой данных. Немножечко изменился интерфейс, поэтому нужно импортировать OpenAI и вставить ключ. Здорово, что я это показал. Видимо, недавно обновили интерфейс самого чата.

Итак, давайте возьмем интерфейсы отсюда. Мы импортируем OpenAI, и дальше смотрим, что нам нужно создать объект Open и передать ему ключ. Мы берем ключ из конфигурации, он называется OpenAI. Мы создали объект, и после этого у нас будет одна основная функция, которую я сразу экспортирую. Это будет асинхронная функция.

Далее обернем всё в блок try-catch, чтобы обработать возможные ошибки. Если произойдет ошибка, мы выведем её в консоль с сообщением о том, что ошибка произошла при попытке сделать chat-completion.

Теперь мы можем описывать функционал OpenAI. У него достаточно много возможностей. Давайте посмотрим в документации. Мы обращаемся к chat.completion.create. На самом деле, можно всё скопировать, как это делают более опытные разработчики. Зачем что-то писать с нуля, если можно это скопировать? Единственное, что я изменю, это вынесу модель в отдельную константу chatGPTModel, чтобы это было более читаемо.

Смотрите, мы передаем массив messages, который нам нужно будет сформировать выше. Поэтому я просто укажу messages, и мы его создадим отдельно. Сейчас объясню, в чем заключается идея. Нам нужно настроить эти сообщения, чтобы получить правильный результат, потому что мы будем получать тезисы. Нам нужна полноценная история.

Давайте в первую очередь создадим константу roles, где у нас будет три роли. Первая — это assistant, у него будет значение "Assistant". Вторая — system, и третья — user. Это три разные роли, с которыми может работать ChatGPT. Assistant отвечает за ответы самого чата, system — это системное значение, которое воспринимает ChatGPT, но не отображается в переписке, а роль пользователя — это то, что отправляем мы как клиенты данного приложения.

Дальше в качестве первого сообщения мы зададим системное сообщение, где объясним чату, что ему делать. Укажем роль system и в качестве контента зададим ему необходимую роль. В данном случае нам важно, чтобы он писал качественный и классный текст, поэтому скажем ему, что он опытный копирайтер, который пишет краткие эмоциональные статьи для социальных сетей.

Существует определённый алгоритм, как правильно строить запросы к ChatGPT, чтобы он выдавал релевантную информацию и строил правильные тексты. Это называется промт-инжиниринг, когда мы задаем определённую роль и структуру запроса, чтобы робот нас понял и выдал то, что нужно. Я сейчас покажу основы, но про это я записал отдельный курс о том, как пользоваться ChatGPT. Ссылка будет в описании, и вы сможете ознакомиться с очень полезным контентом.

После этого сам чат играет новыми красками, потому что это действительно классная технология, которая автоматизирует множество процессов. Я также рассказывал о том, как использовать его для разработчиков. 

Итак, мы в первую очередь определили его роль, и теперь я задам ещё одно сообщение, где будет роль пользователя. В качестве контента я передам getMessage от message — это функция, которую я до сих пор не создал, она будет помогать нам в автоматизации. В качестве параметра сюда я передаю наш message, то есть тезисы, которые мы будем получать от Telegram-бота.

Теперь что касается функции message. Это функция, которая принимает какой-то параметр m, и здесь мы просто возвращаем текст. Мы задали роль для чата, и теперь мы говорим, что непосредственно нужно сделать. Цель нашего запроса: например, написать на основе этих тезисов последовательную эмоциональную историю и указать ему наши тезисы, которые находятся в параметре m.

Давайте создадим ещё контекст, чтобы он точнее понимал, что это за тезисы. Это тезисы с описанием ключевых моментов дня. Необходимо в итоге получить такую историю, чтобы я запомнил этот день и смог впоследствии рассказывать её друзьям. Много текста не нужно, главное, чтобы были эмоции и правильная последовательность, плюс чтение контекста.

Мы задали роль, цель и контекст, и теперь должны получить довольно релевантное значение. Давайте протестируем, как это отрабатывает. Единственное, что нам нужно ещё обработать, это completion. Давайте посмотрим, есть ли что-нибудь в документации по обработке ошибок. 

Раньше можно было стримить, то есть есть два режима работы с ChatGPT. Первый — это когда мы закидываем текст, и он возвращает ответ. Второй вариант — когда мы закидываем текст, и он по чуть-чуть, как в интерфейсе самого чата, начинает выдавать ответ. Это называется стриминг responses. Я подготовил некоторую программу, но вижу, что интерфейс изменился.

Видите, прямо в лайве разбираем стриминг. Они сделали его намного удобнее и проще. Раньше нужно было писать свои костыли, а теперь всё стало проще. Вы можете попробовать это на сайте или в Telegram-боте. В текущем приложении нам это не нужно, потому что мы должны будем всё записывать. Но тем не менее, добавляем параметр stream true, и вот наш контент.

Теперь нам нужно убедиться, что всё это работает, поэтому мы обратимся к completion. Ранее это всё было построено на основе Axios, как я понимаю, они сейчас перешли на свою библиотеку. Давайте в этом убедимся. Переходим в бота, но не можем перейти, потому что он постоянно будет отвечать тестом. Если напишу, то он отвечает тестом, что нам сейчас не нужно. Поэтому давайте вызовем здесь эту функцию для теста.

Это необходимо для того, чтобы всё работало. У нас есть функция, давайте сделаем её асинхронной и подождем, пока выполнится GPT с нашим сообщением. Как его определить? Контекст, по-моему, это будет message.text. Теперь закидываем в него что-нибудь, например, "поел и лег спать". Проверяем, если какие-нибудь ошибки. Пока нет, смотрим в консоль.

Смотрите, что нам выдал. Он выдал роль assistant. Это ответ именно ChatGPT. В итоге в контенте мы видим полноценную историю. Это выглядит очень круто. На основе таких тезисов он написал, что после тяжелого дня, наполненного множеством задач и событий, я наконец смог отдохнуть. 

Ладно, в общем, можете с этим сами развлекаться, это действительно довольно весело. Мы поняли, что всё работает, и давайте продолжим. Дальше я создам файл с названием Notion, потому что теперь нам нужно правильно интегрировать историю в сам Notion. Для этого я его открою. Можно открывать веб-версию или клиент. Если вы не знакомы с тем, что такое Notion, сейчас я добавлю подсказку на ролик о курсе по Notion. Это отличный блокнот, рекомендую его использовать, очень удобно.

Давайте назовем страницу, например, "For YouTube Gram". Здесь мы задаем онлайн-базу данных. Как бы нам назвать базу данных? По сути, мы создали обычную таблицу, но на самом деле это база данных. Мы можем открыть её как полную страницу и хранить все необходимые данные. Первое поле пусть будет name, оно обязательное, мы его не можем изменить, только можем изменить название.

Давайте изменим свойства. Я выберу, что это у нас будет дата, и назову его Date. Мы будем отмечать, когда произошла эта история, естественно, в автоматическом режиме. В принципе, остальной контент можете добавить по умолчанию. В итоге, как я напишу приложение, будет понятно, как это работает. Мы будем весь контент заносить в какую-нибудь историю. Допустим, здесь создам страничку тест. Видите, мы можем его открыть, у него есть дата, и мы будем заносить эту историю сюда.

Вот как это будет выглядеть. Нажимаем Open, здесь уже есть контент. Можем поставить, например, 2 августа. Соответственно, наша тестовая запись. Как нам интегрироваться с Notion? Смотрите, я перехожу по запросу Notion API, нажимаю Get и здесь есть пункт Build Your First Integration. Давайте вместе посмотрим, как это работает. Есть страничка Notion Migrations, переходим на неё и создаем новую интеграцию для рабочего пространства. Я залогинен в Notion. Если у вас есть аккаунт, всё окей.Если нет, просто создайте его. Вы выбираете имя рабочего пространства, допустим, я создам здесь YouTube, Notion, Telegram. Дальше нажимаю "Submit", и у меня есть секрет. Давайте посмотрим, опять же, после того как я запишу ролик, я удалю секрет. Вы делаете по аналогии, то есть у вас будут свои секреты.

Если я создам такую штуку, как Notion, то есть мы не будем обращаться к этому. Давайте посмотрим, что у нас дальше. В принципе, мы закончили. Давайте посмотрим на базовую информацию на всякий случай. Это его разрешение, то есть что он может делать. Вообще, эта интеграция может читать контент, обновлять контент, добавлять контент. Никакой информации про пользователей нам не нужно здесь для того, чтобы делать интеграцию публичной. В принципе, все.

Дальше мы получили вот секрет — это все. Окей. Теперь смотрите, как нам добавить эту интеграцию. Мы переходим в "Connections" и ищем нашу интеграцию. Давайте попробуем это сделать. Вот у нас есть база данных. Я нажимаю три точки, нажимаю "Edit Connections". Так, давайте перейдем на основную страницу. То есть мы сейчас пока находимся в базе данных. Я перейду на ту страничку, которую создал, и попробуем здесь это "Connections". Вот он, YouTube, Notion, Telegram. Я нажимаю "Confirm". Все, мы создали соединение. Теперь интеграция должна проходить.

Давайте посмотрим, что делать дальше. Нам на самом деле нужно получить Page ID, то есть на самом деле идентификатор базы данных. И вот он нам показывает, как примерно это выглядит. Значит, что мы можем сделать? Если вы находитесь в браузере, вам сейчас все будет понятно. Если вы находитесь также в клиенте, то здесь мы нажимаем "Copy Link", для того чтобы перейти в веб-версию. Перехожу сюда, что мы здесь видим? В принципе, ту же самую страницу. Давайте перейдем в базу данных, и здесь нам необходимо скопировать этот идентификатор. То есть это идентификатор базы данных, с которой мы работаем. И вот как раз-таки он нам и нужен. Я его копирую здесь и в коде добавляю еще одно поле — Notion DB ID.

Отлично, все подготовительную работу мы сделали, и дальше мы можем начать разрабатывать. Давайте посмотрим, может быть, что-то есть. Так, сделаю лучше так, быстрее — Notion npm. Да, этот пакетик мы уже установили. Если можем посмотреть, как в принципе всем этим пользоваться, то есть вот мы создаем клиента, добавляем в него поле "aus", и после этого начинаем уже что-либо делать с базами данных.

Давайте покажу, как это работает на практике. У нас есть Notion. Для начала мы, собственно говоря, импортируем сюда, точнее, импортируем что-то из Notion клиента. Класс импортируем, естественно, конфиг. Он позволяет работать с ключами. Создаем объект, нужен через New Client, и сюда мы передаем поле "aus", который равняется конфигу Get Notion Key, если я не ошибаюсь. Давайте проверим. Да, Notion Key нужен.

Дальше здесь по сути я могу просто экспортировать асинхронную функцию, которая будет нам создавать новую запись в базе данных. Я могу просто назвать, например, "Create", и здесь мы будем принимать два параметра: это короткий текст и непосредственно сам текст. Короткий текст — это изначальные тезисы, которые мы отправили в Telegram-бота, а текст — это полный текст, который мы получили уже от ChatGPT.

Соответственно, здесь мы что делаем? Мы ждем, пока Notion этот метод выполнится. Здесь мы указываем и сюда мы передаем Database Config Get Notion DB ID, то есть мы говорим ему, куда вообще необходимо делать нашу запись. После этого, после того как мы указали Parent, здесь мы описываем уже необходимые свойства. 

Смотрите, у нас есть поле "name" — объект, откуда у нас есть поле "name". Вот она называется "name", поэтому здесь я также пишу с ключиком "name". Мы указываем "title". Тут такой необычный формат, достаточно, поэтому у нас массив получается. Внутри массива лежит объект, и дальше мы указываем здесь текст — это объект, у которого есть контент. Если мы передаем "short", то есть "short" короче в поле "name", мы будем записывать короткие тезисы, на основе которых была получена история. Вы же в свою очередь, например, можете сюда передавать идентификатор или любые другие данные. По сути, это его некоторый уникальный идентификатор.

Дальше, то есть с этим мы закончили. Вот у нас "name" закончен. Дальше мы описываем "Date". Это у нас поле "Date", поэтому указываем параметр "start", и когда мы будем записывать, мы будем указывать текущую дату. То есть по сути просто и должен принимать, в принципе, и все. То есть дальше вот эта штука возвращает нам некоторый response, и этот response мы просто возвращаем. Все, метод готов.

Но нужна еще вторая часть, потому что мы хотим, чтобы в записи, которые мы создали, внутри мы записывали уже полноценную историю. Поэтому давайте расширим наш метод. Вот после того, как Notion все это у нас сделал, мы добавим еще следующее. Мы подождем, пока выполнится метод "blocks.children.append". Этот метод есть, мы указываем "block_id", то есть куда вообще нужно все это записывать. А у нас уже есть, как бы, response, то есть страница, с которой мы работаем. По сути, это просто response. И дальше мы указываем, какой контент мы хотим сюда записать. Это у нас массив, и дальше мы перечисляем в объекте то, что у нас будет. 

Object со значением "block_type" у нас это будет "paragraph". Там есть абсолютно разные типы в Notion, то есть там всякие аудио, коллауты, параграфы и прочее. Нас же интересует здесь просто обычный текст. Да, и дальше мы работаем с параграфом. Тоже у нас объект есть, мы указываем параметр "rich_text", потому что будет довольно-таки большой текст. Ну и здесь в качестве объекта мы указываем "type" — "text" и параметр "text", контент текст. Вот этот текст он прилетает нам в качестве аргумента в функцию. В принципе, все у нас готово. Вот эта вот история.

И на самом деле теперь в мыне мы можем уже ее немножечко протестировать. То есть я импортирую, получается, из Notion.js метод "Create", и у нас теперь все готово для того, чтобы сделать интеграцию. Давайте это все закомментирую. Да, напишем логику с нуля. То есть в первую очередь я все обернул в блок try-catch. Если мы получаем некоторую ошибку, допустим, если появилась какая-то ошибка, давайте обозначим место, где она происходит, там, допустим, "gpt" или просто текст. Есть, мы укажем "e", точка, а всю логику описываем тут.

То есть для начала мы просто получаем непосредственно сам текст. Это у нас "context.message.text", который в бота прилетел, который мы сами написали. Дальше можно добавить простую проверку, что если текст — эта строчка у нас, мы его от 3М, то есть удаляем слева пробелы и справа пробелы. Если это у нас пустая история, то тогда мы ответим про то, что вообще-то текст не может быть пустым. Ну, в случае, если мы пустое сообщение отправляем, чтобы не было ошибок там на этапе.

Например, дальше мы получаем некоторые response от GPT, куда мы передаем наш текст. Дальше также можем проверить, что если у нас нет response, то есть от GPT что-то не ответил, мы тогда можем ему, точнее, что мы сделаем? Просто остановим эту функцию и скажем, что пользователю напишем, точнее, ошибка с GPT, и покажем, что у нас находится в response. Вообще-то там по идее будет какое-то описание ошибки. Это в случае, если ChatGPT не отработала.

Дальше поработаем снова, и мы подождем, пока выполняется метод "Create", куда мы передадим непосредственно сам текст. В тексте хранятся в начале тезисы, а полный текст у нас хранится сейчас в response.content. Ну и после этого, если в случае все пошло хорошо, мы обратимся к контексту и скажем, что нам нужно ответить, например, "ваша страница" и укажем URL до этой страницы. Давайте есть поправлена вот эти вот обратные кавычки для того, чтобы была доступна шаблонизация. Есть, добавлю двоеточие, и URL будет храниться в Notion response.

Вот примерно такая логика. Ну, собственно говоря, давайте мы воспользуемся нашей классической, посмотрим, что происходит, посмотрим еще также на консоль. Это займет какое-то время, так как у нас две интеграции здесь сейчас происходят. И вот сразу хочу показать, да, то что это ошибка. Видите, когда мы написали, ничего не происходит. То есть пользователь, который будет этим пользоваться, в принципе, не понимает, работает бот или не работает бот. То есть мы сейчас добавим еще "loader", тоже будет, кажется, интересно.

Так, у нас произошла какая-то ошибка, и я думаю, что понятно, где она произошла, потому что в ChatGPT мы просто выводим это в консоль. Нам необходимо всю эту историю вернуть, так будет правильнее. Давайте остановим процесс, заново запустим и опять отправлю "поел и лег спать". Давайте наблюдать за всеми процессами. То есть видите, да, что сильно напрашивается. У меня есть идея, как сделать прям классно. Интересно, покажу. Специально не ставлю на паузу, чтобы вы видели все эти процессы. Мы получаем URL, открываем. Ну и смотрите, какая красота у нас есть: название наших тезисов и, блин, вот эту историю я хочу прям прочитать.

Эмоциональная история моего дня полна ярких моментов. Утро началось с пробуждения под ласковыми лучами солнца. Открыв глаза, я ощутил прилив энергии и готовность к новым приключениям с радостным. Ладно, я думаю, что понятная идея. Наверное, не буду тратить ваше время, но интересно, так как ChatGPT нафантазировал нас на этих тезисах. Большая история с точки зрения техники, что нам интересно, то что у нас есть парочка пустых страничек, видимо, из-за того, когда мы пытались написать. У нас есть новая запись, можем удалить. Мы открываем, и у нас есть полная история. По-моему, кайф.

Значит, теперь что касается лоадера. Давайте мы его тоже сделаем. Плоды, и здесь мне будет. Я в классном стиле его напишу. Loader у него будет два метода: это будет метод "Show" и будет метод "Hide". Также мне потребуется здесь конструктор, куда мы будем передавать контекст. Ну, если просто добавлю "context = context". Значит, какая идея? Лоадер. Я хочу здесь реализовать, мы будем показывать какие-нибудь движущиеся иконки, типа "время идет", например. Должно быть довольно-таки интересно. Для того чтобы эти иконки получить, мы сейчас проделаем такую вот работу в Телеграме. Я ищу "Emoji Clock" и вот поочередно начинаю их добавлять. Кажется, вот поэтапно. Да, мы все добавили. Можно еще, конечно, разбавить вот этими. В целом, нам этого хватит.Да, концепция заключается в том, что мы просто будем отправлять одно сообщение, редактировать его, и оно будет показывать анимацию загрузки. Когда процесс завершится, мы просто удалим это сообщение. 

Здесь я создам массив иконок. Важно добавить их как обычные элементы строки. Работа сложная и важная, но поверьте мне, это стоит того. 

Итак, у нас есть иконки. Давайте добавим еще одно сообщение, которое будет равняться нулю, и интервал тоже будет равняться нулю. 

Что касается метода Show, давайте сделаем его асинхронным, потому что мы будем работать с контекстом. В первую очередь, в это сообщение я занесу контекст, который мы будем определять при конструкторе. Он доступен через сетевой запрос. 

Когда мы запускаем загрузку, отправляем первую иконку — это первое сообщение, с которым мы работаем. Мы вначале делаем реплей и отвечаем первой иконкой. 

Прошу прощения, не сообщение, а иконку. Без иконок нулевой индекс будем менять, поэтому я создам отдельный индекс, равный нулю, и передам его. Эта штука работает асинхронно, поэтому нам потребуется добавить оператор async. 

У нас есть идентификатор сообщения, с которым мы можем работать, и дальше мы просто будем его менять через определенные промежутки времени. Например, с помощью обычной функции setInterval мы можем это реализовать. Пусть будет, например, каждые полсекунды. Этот интервал мы просто положим в переменную. 

При скрытии мы будем делать интервал. Дальше обращаемся к контексту Telegram. Метод text позволяет редактировать текст сообщения. Мы передаем необходимые параметры: контекст, chat ID — это в каком чате мы работаем, и message ID — это конкретное сообщение, которое мы редактируем. 

Следующий параметр нам не нужен, и дальше мы передаем индекс иконок. Соответственно, нам осталось дописать логику, которая меняет непосредственно этот индекс. 

Я напишу следующим образом: индекс равен, если индекс меньше длины массива иконок, то я вычту единицу. Допустим, длина массива 2, а по индексу последний элемент будет 1. Это основа. 

Дальше передаю индекс + 1, иначе 0. То есть я делаю итерацию по индексу. В случае, если условия не выполняются, мы его обнуляем, то есть зацикливаем. 

Далее мы делаем контекст Telegram, deleteMessage. Обращаемся к chat ID и указываем, какое сообщение мы удаляем. 

Вот такая у нас получилась логика. Давайте теперь добавим это в Main. Нам не нужно импортировать что-то из Loader. Мы знаем, что это будет класс. 

Дальше нам необходимо его создать. Если текст у нас не пустой, то есть проверка была пройдена, я могу создать Loader через new Loader и передать контекст, чтобы он мог оперировать с нашим чатом. 

После этого я просто делаю Loader.show и скрываю перед тем, как покажу URL. 

Давайте попробуем протестировать. Сейчас я напишу какие-то более вменяемые тезисы. Проснулся, даже не проснулся, значит, браузер дома, утром. Потом что я делал? Позавтракал в кафе, поехал, помыл домашнюю бородатую агаму, поехал на студию, пошел на свидание. 

Думаю, что этого будет достаточно. И вот смотрите, мы получаем теперь красивый лазер, который показывает нам, что мы ждем, пока все наши сервисы отработают. 

Естественно, вы можете делать другого формата, придумывать другую логику в целом, но я показал концепцию, как это может выглядеть. 

Все видите, ваша страница создана. Перехожу. Вот наша история: утро началось с чудесного пробуждения. 

Да, это правда. Лёха, 3 часа ночи вчера, и не такое уж чудесное было. Сразу же решил брать дом, ощущение победы, насколько резко прервала. 

Короче, ладно, я думаю, вы поняли идею. На основе каких-то ключевых слов мы написали полноценную историю. Дальше можно это подтачивать под себя. 

Моя задача — показать вам интеграцию. Вот сейчас я почитаю. Благодаря умелым движениям моих рук, домашняя бородатая агама получила свою обязательную порцию заботы. Чувствую себя настоящим зоологом. 

Итак, ладно, переходим к следующей части нашей разработки. В принципе, мы с основой закончили. Давайте займемся дипломом. 

Для этого нам потребуется система контроля версий Git. Запишем в gitignore папку node_modules, обязательно добавим скот. 

Смотрите, нам нужно будет удалить конфиг. Давайте создадим файл, который будет называться .gitignore, и просто заигнорим default.json. Все, больше нам здесь ничего не нужно. 

Далее переходим на GitHub и сразу же попадаем на новый репозиторий. Допустим, я его назову YouTube-GPT-Telegram, пусть будет публичный. Создаю репозиторий. 

Дальше выполняем следующие команды. Это будет git commit -m "Project". Дальше добавляем удаленный URL, связываем его с репозиторием. После этого делаем push. 

Вот он каждый раз просит меня сделать main branch. Не хочу делать его основным, пусть будет master, но опять же на ваше усмотрение. 

Все, репозиторий мы залили. Вот он у нас есть, все красиво работает. Дальше нам нужно его задеплоить, потому что я не хочу, чтобы каждый раз у меня локальный компьютер работал для этого сервиса. 

Я хочу забыть про компьютер, чтобы он просто сам работал, и другие сервера с этим справлялись. Для этого я буду использовать сервис, и сразу же перейду в него. 

Это замечательный сервис, который позволяет нам работать с облачной платформой, с объектами хранилищами и так далее. Я вам сейчас покажу, как с помощью него можно быстро задеплоить Telegram-бота и сэкономить на этом деньги. 

Смотрите, мы переходим в облачную платформу. Здесь выбираем проект. Как видите, у меня есть созданный проект GPT. Вы можете создать новый проект для того, чтобы задеплоить конкретно ваш проект. 

На текущий момент в проекте GPT у меня уже есть сервер. Я готовился, поэтому сейчас удалю его и покажу, как все делается с нуля. 

Сейчас у нас нет ни одного сервера, поэтому нам необходимо его создать. Создаем. Пусть его имя будет Store Trailer. Окей, регион я выберу Санкт-Петербург. У них есть сервера в Москве и в Питере, а также в Ташкенте, Алматы и Новосибирске. 

Супер, пул я выберу здесь RU3B. В качестве источника мы можем выбирать различные операционные системы с разными версиями. В моем случае это будет Ubuntu 22.04, память 512 мегабайт и диск 8 гигов. 

Смотрите, очень важный момент: есть различные настройки для сервера в зависимости от требований вашего проекта. Если мы работаем с Telegram-ботом, то можем оптимизировать стоимость. 

Параметр shared line позволяет делить вычислительные мощности процессоров. Нам, например, хватит 20% CPU для работы Telegram, потому что он не очень ресурсоемкий. Я выбираю один CPU, 20%, тем самым мы сэкономим деньги. 

Смотрим остальные настройки. Это нам будет стоить всего лишь 17 рублей в день. Можем посмотреть, какая стоимость в месяц и в час. 

Давайте проверим еще настройки. Сделаем публичную подсеть и укажем здесь 29. Все сделали, нажимаю создать. 

Сервер готов, и сейчас мы будем заниматься дипломом. Есть разные способы для того, чтобы задеплоить приложение. Дождемся, пока сервер заработает, это займет пару минут. 

Покажу вам много магии с Ubuntu. Все, видите, я даже на паузу не ставил, сервер активен и очень быстро работает. Перехожу в сервер. 

Здесь не требуется консоль. Можно подключаться по SSH, а можно работать прямо в браузере. Я выберу путь через браузер, потому что все уже на месте. 

Логин — root. Убираю пароль. Смотрите, пароль мы делаем следующим образом: нажимаем на клавишу клавиатуры и выбираем пароль. 

Все, у нас есть доступ к консоли. Что мы делаем дальше? В первую очередь я обращаюсь и нажимаю update, чтобы обновить систему, скачать все необходимые зависимости и так далее. 

Все готово. Дальше мы можем установить Git, он нам потребуется. apt install git. Если нажимаем Yes, супер. 

Теперь мы установили Git. Можно проверить, все команды доступны. С помощью Git мы, естественно, склонируем репозиторий. Далее нам необходимо установить Node.js. 

Тут есть определенные нюансы, это чуть сложнее, чем на Mac или Windows. Давайте попробуем найти инструкцию для этого.Значит, все понятно, что нас здесь интересует. Мы хотим установить такую штуку, как NVM. NVM — это Node Version Manager, который позволяет устанавливать различные версии Node.js непосредственно.

Собственно говоря, если перейти к способу номер один, то вначале мы обновляем систему. Дальше мы устанавливаем необходимые зависимости. Я просто вставляю эту команду и нажимаю Enter — она быстро устанавливается. Затем мы устанавливаем непосредственно NVM. Опять же, просто копирую команду.

Давайте посмотрим, что у нас сейчас. По документации нам нужно запустить еще одну команду. Проверяем: все работает. Супер! Теперь мы устанавливаем необходимую версию Node.js. Для этого мы пишем `nvm install 20`. Здесь мы можем указывать конкретную версию, которую необходимо установить. В целом, версия 20 нам более чем достаточно для того, чтобы все работало. Дальше мы делаем `nvm use 20`, чтобы перейти на эту версию. Проверяем: `node -v` показывает 20, а `npm -v` — 9.8.0. Супер, все готово!

Теперь мы копируем URL нашего репозитория и выполняем команду `git clone`. Проверяем, переходим в репозиторий и смотрим, что у нас здесь есть. Главное, чтобы у нас была папка `config` и `src`. Сразу же делаем `ls`, проверяем, что появились `node_modules`.

Теперь, если мы перейдем в `config` и проверим, у нас там только файл `keep`, а нам нужен хотя бы один конфигурационный файл, например, `default.json`. Почему я его не положил в Git? Потому что все бы увидели мои ключи и начали бы ими пользоваться, а я этого не хочу. То есть я делаю `touch default.json`. 

Дальше делаю `nano default.json`. Видите, это пустой файл. Для ролика я просто скопирую наши ключи для разработки, чтобы это работало. Вставляю. Естественно, сюда по-хорошему нужно вставлять продакшен-ключи, которые работают с нормальными базами данных и так далее. Вот мы сюда все это вставили. Дальше нажимаю `Ctrl + X`, затем `Y` и `Enter`.

Давайте проверим еще раз, что у нас все хорошо. `nano default.json` — видите, тут уже есть контент. Все, отлично! Теперь делаю `cd ..`, чтобы оказаться в корне нашего проекта. В принципе, мы теперь можем просто запустить всю эту историю. Однако я запущу ее в фоновом режиме с помощью пакета `pm2`. Устанавливаю его глобально: `npm install -g pm2`. 

Зачем в фоне? Это делается для того, чтобы мы не сидели с открытой консолью. Если мы закроем консоль, тогда процесс прервется, и смысла в этом не будет. Дальше проверяем: `pm2 list`. Он нам выдает информацию. Замечательно! Теперь просто обращаемся к `pm2` и запускаем скрипт, который находится в папке `src/main.js`. Все, видите, у нас есть процесс. Проверяем, что это работает. Локально процесс не запущен, так что давайте покажу документацию по `pm2`.

Вот пакет, он довольно популярный. Мы запустили наш скрипт в фоне. Можно проверять список запущенных процессов, останавливать нужный процесс, перезапускать, удалять и так далее. Это довольно простые команды.

У нас есть какая-то ошибка. Смотрите, в чем здесь ошибка: получается, мы передали больше контента в Notion, чем он ожидает. Нам нужно будет по-хорошему еще эту историю ограничить. Но вообще-то это хорошо, потому что у нас есть понимание, что все отработало как нужно.

Соответственно, покажу вам, как это все перезапускать. `pm2 delete main`. Давайте так: `pm2 list`, `pm2 delete main`. Дальше мы переходим в ChatGPT и давайте поправим здесь условия. Текст должен быть больше, допустим, 100 слов. Вот так вот попробуем сделать.

Что мы делаем? `git add .`, обновляем его в репозитории. `git commit -m "Update message"`. После этого мы переходим на наш сервер и запускаем всю эту историю. То есть мы просто обновили через `git` наш контент в `src/main.js`. Все, мы запустили процесс и попробуем еще раз.

`pm2 logs` — у меня есть предположение, что это старые логи. Да, это были старые логи. Смотрите, мы получили новую страничку, и вот наша история. Валидацию можно сделать чуть посложнее, чуть поинтереснее, например, проверять по количеству символов или добавлять новый блок. Но в целом это уже детали.

Я показал вам, как это все происходит с точки зрения интеграции и деплоя. Теперь, собственно говоря, смотрите: `pm2 list`. У нас есть процесс, то есть мы можем все это закрыть, и наш бот будет работать. Он проснулся и уснул — самая лучшая история за сегодняшний день. 

В общем, ребята, развлекайтесь! На самом деле, это действительно прикольно. Обладая навыками автоматизации и программирования, можно придумывать любые задачи и реализовывать их. Как видите, можно сделать более практичную тему, например, бот, который записывает важные дела с помощью ChatGPT, обрабатывает их или просто принимает голосовые команды и превращает их в текст. 

Таким образом, можно создавать новые задачи для команды. Простор для фантазии здесь безграничный. Пользуйтесь этой структурой, дорабатывайте ее для себя. Классные облачные сервера — сам их использую. Все, воды больше лить не буду. До встречи